import type { Exam, Question, QuestionType } from '../types';

/**
 * Solver Agent
 * Responsible for generating questions "Just-in-Time" using AI (Bedrock).
 * It respects official domain weights and prevents hallucinations.
 */
export class SolverAgent {
    /**
     * Generates a single question based on the exam blueprint.
     */
    async generateQuestion(exam: Exam, difficulty: string = 'intermediate'): Promise<Question> {
        console.log(`Solver: Generating question for ${exam.name} [Diff: ${difficulty}]...`);

        const domain = this.selectDomainByWeight(exam);

        await new Promise(resolve => setTimeout(resolve, 1500));

        const type: QuestionType = Math.random() > 0.3 ? 'single_select' : 'multi_select';

        return {
            id: `q-${Math.random().toString(36).substr(2, 9)}`,
            type,
            question_text: `Mocked Question about ${domain.name}: This is a scenario-based question generated by the AI agent. ${type === 'multi_select' ? '(Select 2)' : '(Select 1)'}`,
            options: [
                { id: 'A', text: `Option related to ${domain.name} Service X` },
                { id: 'B', text: `Option related to ${domain.name} Service Y` },
                { id: 'C', text: `Option related to ${domain.name} Service Z` },
                { id: 'D', text: `Option related to ${domain.name} Best Practices` },
            ],
            correct_ids: type === 'multi_select' ? ['A', 'C'] : ['B'],
            explanation: `This is a detailed explanation in the user's language. It clarifies why the chosen options are correct based on documentation for ${domain.name}.`,
            domain: domain.name,
            official_link: 'https://docs.aws.amazon.com/example'
        };
    }

    private selectDomainByWeight(exam: Exam) {
        const totalWeight = exam.domains.reduce((sum, d) => sum + d.weight, 0);
        let random = Math.random() * totalWeight;

        for (const domain of exam.domains) {
            if (random < domain.weight) return domain;
            random -= domain.weight;
        }

        return exam.domains[0];
    }
}

export const solver = new SolverAgent();
